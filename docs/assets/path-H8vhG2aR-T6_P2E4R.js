const x=Math.PI,y=2*x,l=1e-6,E=y-l;function m(e){this._+=e[0];for(let t=1,i=e.length;t<i;++t)this._+=arguments[t]+e[t]}function L(e){let t=Math.floor(e);if(!(t>=0))throw new Error(`invalid digits: ${e}`);if(t>15)return m;const i=10**t;return function(s){this._+=s[0];for(let h=1,n=s.length;h<n;++h)this._+=Math.round(arguments[h]*i)/i+s[h]}}class M{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=t==null?m:L(t)}moveTo(t,i){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,i){this._append`L${this._x1=+t},${this._y1=+i}`}quadraticCurveTo(t,i,s,h){this._append`Q${+t},${+i},${this._x1=+s},${this._y1=+h}`}bezierCurveTo(t,i,s,h,n,a){this._append`C${+t},${+i},${+s},${+h},${this._x1=+n},${this._y1=+a}`}arcTo(t,i,s,h,n){if(t=+t,i=+i,s=+s,h=+h,n=+n,n<0)throw new Error(`negative radius: ${n}`);let a=this._x1,u=this._y1,p=s-t,$=h-i,_=a-t,o=u-i,r=_*_+o*o;if(this._x1===null)this._append`M${this._x1=t},${this._y1=i}`;else if(r>l)if(!(Math.abs(o*p-$*_)>l)||!n)this._append`L${this._x1=t},${this._y1=i}`;else{let d=s-a,c=h-u,g=p*p+$*$,A=d*d+c*c,w=Math.sqrt(g),v=Math.sqrt(r),b=n*Math.tan((x-Math.acos((g+r-A)/(2*w*v)))/2),f=b/v,T=b/w;Math.abs(f-1)>l&&this._append`L${t+f*_},${i+f*o}`,this._append`A${n},${n},0,0,${+(o*d>_*c)},${this._x1=t+T*p},${this._y1=i+T*$}`}}arc(t,i,s,h,n,a){if(t=+t,i=+i,s=+s,a=!!a,s<0)throw new Error(`negative radius: ${s}`);let u=s*Math.cos(h),p=s*Math.sin(h),$=t+u,_=i+p,o=1^a,r=a?h-n:n-h;this._x1===null?this._append`M${$},${_}`:(Math.abs(this._x1-$)>l||Math.abs(this._y1-_)>l)&&this._append`L${$},${_}`,s&&(r<0&&(r=r%y+y),r>E?this._append`A${s},${s},0,1,${o},${t-u},${i-p}A${s},${s},0,1,${o},${this._x1=$},${this._y1=_}`:r>l&&this._append`A${s},${s},0,${+(r>=x)},${o},${this._x1=t+s*Math.cos(n)},${this._y1=i+s*Math.sin(n)}`)}rect(t,i,s,h){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}h${s=+s}v${+h}h${-s}Z`}toString(){return this._}}function q(){return new M}q.prototype=M.prototype;function C(e){return function(){return e}}function P(e){let t=3;return e.digits=function(i){if(!arguments.length)return t;if(i==null)t=null;else{const s=Math.floor(i);if(!(s>=0))throw new RangeError(`invalid digits: ${i}`);t=s}return e},()=>new M(t)}export{P as C,q as P,C as q};
